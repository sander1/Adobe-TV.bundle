import re

PREF_MAP = {'720p':'HD', 'Medium':'MED', 'Low':'LOW'}
ORDER = ['HD', 'MED', 'LOW']

HTTP.CacheTime = CACHE_1DAY
HTTP.Headers['User-Agent'] = 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_7; en-us) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/5.0.4 Safari/533.20.27'

####################################################################################################
def NormalizeURL(url):
  return url

####################################################################################################
def MetadataObjectForURL(url):
  html = HTML.ElementFromURL(url, errors='ignore')

  try:
    rating = html.xpath('//div[@class="rating"]//span[@style][1]')[0].get('style')
    rating = re.search('width.+?([0-9]+)%', rating).group(1)
    rating = float(rating)/10
  except:
    rating = None

  tags = []
  for tag in html.xpath('//div[@class="tags"]/a'):
    tags.append(tag.text.strip())

  video = VideoClipObject(
    title = html.xpath('//div[contains(@class, "masthead")]//span[@class="episode_title"]')[0].text.strip(),
    tagline = html.xpath('//div[contains(@class, "masthead")]/h2/a')[0].text.strip(),
    summary = html.xpath('//meta[@name="description"]')[0].get('content'),
    originally_available_at = Datetime.ParseDate(html.xpath('//meta[@name="datepublished"]')[0].get('content')).date(),
    duration = CalculateDuration(html.xpath('//meta[@name="duration"]')[0].get('content')),
    thumb = html.xpath('//meta[@name="thumbnail"]')[0].get('content'),
    rating = rating,
    tags = tags
  )

  return video

####################################################################################################
def MediaObjectsForURL(url):
  Log(" --> MediaObjectsForURL")

  return [
    MediaObject(
      parts = [PartObject(key=Callback(PlayVideo, url=url))]
    )
  ]

####################################################################################################
@indirect
def PlayVideo(url, fmt=None):
  Log(" --> PlayVideo")
  if not fmt:
    fmt = Prefs['video_quality']

  video_src = HTML.ElementFromURL(url, errors='ignore').xpath('//head/link[@rel="video_src"]')[0].get('href')
  vid = re.search('fileID=([0-9]+).+context=([0-9]+)', video_src)
  file_id = int(vid.group(1))
  context = int(vid.group(2))

  video_url = AmfRequest(file_id, context, fmt)
  Log(" --> " + video_url)

  if video_url.find('edgeboss') != -1:
    xml = XML.ElementFromURL(video_url, errors='ignore').xpath('//entry')[0]
    video_url = xml.xpath('./streamName')[0].text
    video_url = re.sub('^flash', 'http://adobe.edgeboss.net/download/adobe', video_url)
    video_url = re.sub('\.uid\.[^.]+\.(.+?)$', '\1.flv')

    Log(" --> edgeboss: " + video_url)

  if video_url.startswith('http'):
    if video_url.endswith('.mp4'):
      protocols = [Protocol.HTTPMP4Streaming]
    else:
      protocols = [Protocol.HTTPVideo]
  elif video_url.startswith('rtmp'):
    (streamer, stream_name) = url.split('/ondemand/')
    streamer += '/ondemand'
    if stream_name.find('.mp4') != -1:
      stream_name = 'mp4:' + file[:-4]
    elif stream_name.find('.flv') != -1:
      stream_name = stream_name[:-4]
    video_url = RTMPVideoURL(url=streamer, clip=stream_name)
    protocols = [Protocol.RTMP]
  else:
    video_url = None
    protocols = []

  oc = ObjectContainer()
  oc.add(VideoClipObject(
    key = URLService.LookupURLForMediaURL(url),
    items = [
      MediaObject(
        parts = [
          PartObject(key = video_url)
        ],
        protocols = protocols
      )
    ]
  ))

  return oc

####################################################################################################
def AmfRequest(file_id, context, fmt):
  client = AMF.RemotingService('http://tv.adobe.com/flashservices/gateway', amf_version=3, user_agent='Shockwave Flash')
  service = client.getService('services.player')
  result = service.load(file_id, False, context)

  # If there are multiple videos to select from...
  if 'VIDEOS' in result:
    pref_value = PREF_MAP[fmt]
    available = {}

    for version in result['VIDEOS']:
      # Prefer http over rtmp
      if 'PROGRESSIVE' in version:
        video_url = version['PROGRESSIVE']
      elif 'CDNURL' in version:
        video_url = version['CDNURL']

      q = version['QUALITY']
      if q in ORDER:
        available[q] = video_url

    for i in range(ORDER.index(pref_value), len(ORDER)):
      quality = ORDER[i]
      if quality in available:
        return available[quality]

  # ...or if there is just one version available (prefer http over rtmp)
  elif 'PROGRESSIVE' in result:
    return result['PROGRESSIVE']
  elif 'CDNURL' in result:
    return result['CDNURL']
  else:
    return None

####################################################################################################
def CalculateDuration(timecode):
  milliseconds = 0
  d = re.search('([0-9]{2}):([0-9]{2}):([0-9]{2})', timecode)
  milliseconds += int( d.group(1) ) * 60 * 60 * 1000
  milliseconds += int( d.group(2) ) * 60 * 1000
  milliseconds += int( d.group(3) ) * 1000
  return milliseconds
